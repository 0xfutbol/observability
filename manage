#!/usr/bin/env bash

set -e

# Colors for better UX
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

ENV_FILE=".env"
SERVICE_NAME="observability"
CONFIG_FILE="promtail/promtail-config.yaml"
TEMP_FILE=$(mktemp)

# Function to print colored header
print_header() {
    echo -e "${CYAN}========================================${NC}"
    echo -e "${CYAN}     Observability Stack Manager       ${NC}"
    echo -e "${CYAN}========================================${NC}"
    echo
}

# Function to prompt for env vars (from original setup.sh)
create_env() {
    echo -e "${GREEN}Creating .env file...${NC}"
    echo
    
    # Grafana configuration
    echo -e "${BLUE}=== Grafana Configuration ===${NC}"
    echo -e "${YELLOW}Grafana will use default configuration.${NC}"
    echo
    
    # Metabase configuration
    echo -e "${BLUE}=== Metabase Configuration ===${NC}"
    read -p "Enter Metabase Database connection URI: " MB_DB_CONNECTION_URI
    read -p "Enter Metabase Site URL (default: http://localhost/metabase): " MB_SITE_URL
    MB_SITE_URL=${MB_SITE_URL:-http://localhost/metabase}
    echo
    
    # AWS configuration (for S3 bucket mounting)
    echo -e "${BLUE}=== AWS Configuration ===${NC}"
    echo -e "${YELLOW}Configure AWS credentials for S3 bucket mounting${NC}"
    read -p "Enter AWS Access Key ID: " AWS_ACCESS_KEY_ID
    read -p "Enter AWS Secret Access Key: " AWS_SECRET_ACCESS_KEY
    read -p "Enter AWS Region (default: us-east-1): " AWS_REGION
    AWS_REGION=${AWS_REGION:-us-east-1}
    echo
    
    # Write to .env file
    {
        echo "# Metabase Configuration"
        echo "MB_DB_CONNECTION_URI=\"$MB_DB_CONNECTION_URI\""
        echo "MB_SITE_URL=\"$MB_SITE_URL\""
        echo
        echo "# AWS Configuration (for S3 bucket mounting)"
        echo "AWS_ACCESS_KEY_ID=\"$AWS_ACCESS_KEY_ID\""
        echo "AWS_SECRET_ACCESS_KEY=\"$AWS_SECRET_ACCESS_KEY\""
        echo "AWS_REGION=\"$AWS_REGION\""
    } > "$ENV_FILE"
    echo -e "${GREEN}.env file created.${NC}"
}

# Function to set up systemd service (from original setup.sh)
setup_systemd_service() {
    echo -e "${BLUE}Setting up systemd service...${NC}"
    
    # Create systemd service file
    SERVICE_FILE="/etc/systemd/system/$SERVICE_NAME.service"

    sudo bash -c "cat > $SERVICE_FILE" <<EOL
[Unit]
Description=Observability Docker Compose Stack
After=network.target

[Service]
Type=simple
WorkingDirectory=$(pwd)
ExecStart=/usr/bin/docker compose up
ExecStop=/usr/bin/docker compose down
Restart=on-failure
RestartSec=10
StartLimitIntervalSec=600
StartLimitBurst=3
EnvironmentFile=$(pwd)/.env

[Install]
WantedBy=multi-user.target
EOL

    echo -e "${BLUE}Reloading systemd daemon and enabling service...${NC}"
    sudo systemctl daemon-reload
    sudo systemctl enable $SERVICE_NAME
    sudo systemctl restart $SERVICE_NAME

    # Get public IP
    PUBLIC_IP=$(curl -4 -s ifconfig.me || curl -4 -s ipinfo.io/ip || echo "<your-ipv4>")

    # Print access URLs
    cat <<EOF

${GREEN}Service $SERVICE_NAME is set up and running.${NC}

${CYAN}Access your services at:${NC}
  ${YELLOW}Grafana:   http://$PUBLIC_IP/grafana${NC}
  ${YELLOW}Metabase:  http://$PUBLIC_IP/metabase${NC}
EOF
}

# Function to check if s3fs is installed
check_s3fs() {
    if ! command -v s3fs &> /dev/null; then
        echo -e "${YELLOW}s3fs is not installed. Installing...${NC}"
        
        # Detect OS and install s3fs
        if [[ "$OSTYPE" == "linux-gnu"* ]]; then
            if command -v apt &> /dev/null; then
                sudo apt update && sudo apt install -y s3fs
            elif command -v yum &> /dev/null; then
                sudo yum install -y s3fs-fuse
            elif command -v dnf &> /dev/null; then
                sudo dnf install -y s3fs-fuse
            else
                echo -e "${RED}Error: Cannot install s3fs automatically. Please install it manually.${NC}"
                return 1
            fi
        elif [[ "$OSTYPE" == "darwin"* ]]; then
            if command -v brew &> /dev/null; then
                brew install s3fs
            else
                echo -e "${RED}Error: Homebrew not found. Please install s3fs manually: brew install s3fs${NC}"
                return 1
            fi
        else
            echo -e "${RED}Error: Unsupported OS. Please install s3fs manually.${NC}"
            return 1
        fi
        
        echo -e "${GREEN}✓ s3fs installed successfully!${NC}"
    else
        echo -e "${GREEN}✓ s3fs is already installed.${NC}"
    fi
}

# Function to show current S3 mounts
show_s3_mounts() {
    echo -e "${BLUE}Current S3 Bucket Mounts:${NC}"
    echo -e "${BLUE}==========================${NC}"
    
    # Check for mounted s3fs filesystems
    local s3_mounts=$(mount | grep s3fs | awk '{print $1 " -> " $3}' || echo "")
    
    if [ -z "$s3_mounts" ]; then
        echo -e "${YELLOW}No S3 buckets are currently mounted.${NC}"
        echo
        
        # Check for mount points directory
        if [ -d "/mnt/s3-logs" ]; then
            echo -e "${BLUE}Available mount point directories:${NC}"
            ls -la /mnt/s3-logs/ 2>/dev/null | grep "^d" | awk '{print "  " $9}' | grep -v "^\.$\|^\.\.$" || echo -e "${YELLOW}  No mount directories found.${NC}"
        fi
        echo
        return 1
    else
        local index=1
        while IFS= read -r mount; do
            echo -e "${GREEN}$index.${NC} $mount"
            ((index++))
        done <<< "$s3_mounts"
        echo
        return 0
    fi
}

# Function to create credentials file for s3fs
create_s3fs_credentials() {
    local access_key="$1"
    local secret_key="$2"
    local creds_file="$HOME/.passwd-s3fs"
    
    # Create credentials file
    echo "$access_key:$secret_key" > "$creds_file"
    chmod 600 "$creds_file"
    echo -e "${GREEN}✓ S3 credentials file created at $creds_file${NC}"
}

# Function to get Promtail job template for mounted S3 logs
get_promtail_s3_template() {
    local job_name="$1"
    local mount_path="$2"
    local log_pattern="${3:-**/*.log}"
    
    cat <<EOF
  - job_name: $job_name
    static_configs:
      - targets:
          - localhost
        labels:
          job: "s3_logs"
          source: "$job_name"
          __path__: "$mount_path/$log_pattern"
    pipeline_stages:
      - json:
          expressions:
            timestamp: time
            message: msg
            level: level
      - timestamp:
          source: timestamp
          format: RFC3339
      - labels:
          level:
      - output:
          source: message
EOF
}

# Function to mount S3 bucket
mount_s3_bucket() {
    echo -e "${GREEN}Mount New S3 Bucket${NC}"
    echo -e "${GREEN}===================${NC}"
    
    # Check if s3fs is installed
    check_s3fs || return 1
    
    read -p "Enter mount name (e.g., app_logs): " mount_name
    read -p "Enter S3 bucket name: " bucket
    read -p "Enter S3 bucket prefix/path (optional, e.g., logs/app/): " prefix
    read -p "Enter log file pattern (default: **/*.log): " log_pattern
    log_pattern=${log_pattern:-**/*.log}
    
    # Validate inputs
    if [ -z "$mount_name" ] || [ -z "$bucket" ]; then
        echo -e "${RED}Error: Mount name and bucket are required.${NC}"
        return 1
    fi
    
    # Create mount point
    local mount_path="/mnt/s3-logs/$mount_name"
    sudo mkdir -p "$mount_path"
    
    # Check for AWS credentials from environment variables
    local creds_file="$HOME/.passwd-s3fs"
    if [ ! -f "$creds_file" ]; then
        if [ -n "$AWS_ACCESS_KEY_ID" ] && [ -n "$AWS_SECRET_ACCESS_KEY" ]; then
            echo -e "${GREEN}✓ Using AWS credentials from environment variables.${NC}"
            create_s3fs_credentials "$AWS_ACCESS_KEY_ID" "$AWS_SECRET_ACCESS_KEY"
        else
            echo -e "${RED}Error: AWS credentials not found in environment variables.${NC}"
            echo -e "${YELLOW}Please run the initial setup to configure AWS credentials.${NC}"
            return 1
        fi
    else
        echo -e "${GREEN}✓ Using existing AWS credentials file.${NC}"
    fi
    
    # Construct s3fs bucket path
    local bucket_path="$bucket"
    if [ -n "$prefix" ]; then
        # Ensure prefix starts with / and remove trailing slash
        prefix=$(echo "$prefix" | sed 's|^/*|/|' | sed 's|/$||')
        bucket_path="$bucket:$prefix"
    fi
    
    # Mount the S3 bucket
    echo -e "${BLUE}Mounting S3 bucket: $bucket_path -> $mount_path${NC}"
    
    # Set AWS region from environment variables
    local aws_region="${AWS_DEFAULT_REGION:-${AWS_REGION:-us-east-1}}"
    echo -e "${BLUE}Using AWS region: $aws_region${NC}"
    
    # Construct S3 endpoint URL for the region
    local s3_endpoint="https://s3.$aws_region.amazonaws.com"
    if [ "$aws_region" = "us-east-1" ]; then
        s3_endpoint="https://s3.amazonaws.com"
    fi
    
    local mount_opts="allow_other,use_cache=/tmp/s3fs-cache,uid=$(id -u),gid=$(id -g),url=$s3_endpoint"
    if sudo s3fs "$bucket_path" "$mount_path" -o "$mount_opts"; then
        echo -e "${GREEN}✓ S3 bucket mounted successfully!${NC}"
        
        # Add to Promtail configuration
        local promtail_config=$(get_promtail_s3_template "$mount_name" "$mount_path" "$log_pattern")
        echo "$promtail_config" >> "$CONFIG_FILE"
        
        # Add to fstab for persistence
        local fstab_entry="$bucket_path $mount_path fuse.s3fs _netdev,$mount_opts 0 0"
        if ! grep -q "$mount_path" /etc/fstab; then
            echo "$fstab_entry" | sudo tee -a /etc/fstab
            echo -e "${GREEN}✓ Added to /etc/fstab for automatic mounting.${NC}"
        fi
        
        echo -e "${GREEN}✓ Promtail configuration updated.${NC}"
        echo -e "${BLUE}Mount path: $mount_path${NC}"
        echo -e "${BLUE}Log pattern: $log_pattern${NC}"
    else
        echo -e "${RED}✗ Failed to mount S3 bucket.${NC}"
        return 1
    fi
    
    echo
}

# Function to unmount S3 bucket
unmount_s3_bucket() {
    if ! show_s3_mounts; then
        return 1
    fi
    
    echo -e "${YELLOW}Unmount S3 Bucket${NC}"
    echo -e "${YELLOW}=================${NC}"
    
    read -p "Enter the mount name to remove: " mount_name
    
    if [ -z "$mount_name" ]; then
        echo -e "${RED}Error: Mount name is required.${NC}"
        return 1
    fi
    
    local mount_path="/mnt/s3-logs/$mount_name"
    
    # Check if mount exists
    if ! mount | grep -q "$mount_path"; then
        echo -e "${RED}Error: Mount '$mount_name' not found at $mount_path.${NC}"
        return 1
    fi
    
    # Confirm deletion
    echo -e "${YELLOW}Are you sure you want to unmount '$mount_name' from $mount_path? (y/N)${NC}"
    read -r confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Operation cancelled.${NC}"
        return 0
    fi
    
    # Unmount the S3 bucket
    echo -e "${BLUE}Unmounting S3 bucket from $mount_path...${NC}"
    if sudo umount "$mount_path"; then
        echo -e "${GREEN}✓ S3 bucket unmounted successfully!${NC}"
        
        # Remove from fstab
        if grep -q "$mount_path" /etc/fstab; then
            sudo sed -i "\|$mount_path|d" /etc/fstab
            echo -e "${GREEN}✓ Removed from /etc/fstab.${NC}"
        fi
        
        # Remove mount directory
        sudo rmdir "$mount_path" 2>/dev/null
        echo -e "${GREEN}✓ Mount directory removed.${NC}"
        
        # Remove from Promtail configuration
        python3 -c "
import re
import sys

with open('$CONFIG_FILE', 'r') as f:
    content = f.read()

# Pattern to match the specific job and its configuration
pattern = r'  - job_name: $mount_name\n(.*?)(?=  - job_name:|$)'
result = re.sub(pattern, '', content, flags=re.DOTALL)

with open('$CONFIG_FILE', 'w') as f:
    f.write(result)
"
        echo -e "${GREEN}✓ Promtail configuration updated.${NC}"
    else
        echo -e "${RED}✗ Failed to unmount S3 bucket.${NC}"
        return 1
    fi
    
    echo
}

# Function to remount S3 bucket (edit)
remount_s3_bucket() {
    if ! show_s3_mounts; then
        return 1
    fi
    
    echo -e "${PURPLE}Remount S3 Bucket${NC}"
    echo -e "${PURPLE}=================${NC}"
    
    read -p "Enter the mount name to edit: " mount_name
    
    if [ -z "$mount_name" ]; then
        echo -e "${RED}Error: Mount name is required.${NC}"
        return 1
    fi
    
    local mount_path="/mnt/s3-logs/$mount_name"
    
    # Check if mount exists
    if ! mount | grep -q "$mount_path"; then
        echo -e "${RED}Error: Mount '$mount_name' not found at $mount_path.${NC}"
        return 1
    fi
    
    echo -e "${BLUE}Current mount: $mount_path${NC}"
    echo -e "${YELLOW}To edit a mount, we'll unmount and remount with new settings.${NC}"
    echo
    
    # Confirm remount
    echo -e "${YELLOW}Do you want to proceed with remounting '$mount_name'? (y/N)${NC}"
    read -r confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Operation cancelled.${NC}"
        return 0
    fi
    
    # Get new mount details
    read -p "Enter S3 bucket name: " bucket
    read -p "Enter S3 bucket prefix/path (optional): " prefix
    read -p "Enter log file pattern (default: **/*.log): " log_pattern
    log_pattern=${log_pattern:-**/*.log}
    
    if [ -z "$bucket" ]; then
        echo -e "${RED}Error: Bucket name is required.${NC}"
        return 1
    fi
    
    # Unmount existing
    echo -e "${BLUE}Unmounting existing mount...${NC}"
    sudo umount "$mount_path"
    
    # Remove old Promtail config
    python3 -c "
import re
import sys

with open('$CONFIG_FILE', 'r') as f:
    content = f.read()

pattern = r'  - job_name: $mount_name\n(.*?)(?=  - job_name:|$)'
content = re.sub(pattern, '', content, flags=re.DOTALL)

with open('$CONFIG_FILE', 'w') as f:
    f.write(content)
"
    
    # Construct new bucket path
    local bucket_path="$bucket"
    if [ -n "$prefix" ]; then
        # Ensure prefix starts with / and remove trailing slash
        prefix=$(echo "$prefix" | sed 's|^/*|/|' | sed 's|/$||')
        bucket_path="$bucket:$prefix"
    fi
    
    # Remount with new settings
    echo -e "${BLUE}Remounting with new settings: $bucket_path -> $mount_path${NC}"
    
    # Set AWS region from environment variables
    local aws_region="${AWS_DEFAULT_REGION:-${AWS_REGION:-us-east-1}}"
    echo -e "${BLUE}Using AWS region: $aws_region${NC}"
    
    # Construct S3 endpoint URL for the region
    local s3_endpoint="https://s3.$aws_region.amazonaws.com"
    if [ "$aws_region" = "us-east-1" ]; then
        s3_endpoint="https://s3.amazonaws.com"
    fi
    
    local mount_opts="allow_other,use_cache=/tmp/s3fs-cache,uid=$(id -u),gid=$(id -g),url=$s3_endpoint"
    
    if sudo s3fs "$bucket_path" "$mount_path" -o "$mount_opts"; then
        echo -e "${GREEN}✓ S3 bucket remounted successfully!${NC}"
        
        # Update Promtail configuration
        local promtail_config=$(get_promtail_s3_template "$mount_name" "$mount_path" "$log_pattern")
        echo "$promtail_config" >> "$CONFIG_FILE"
        
        # Update fstab
        sudo sed -i "\|$mount_path|d" /etc/fstab
        local fstab_entry="$bucket_path $mount_path fuse.s3fs _netdev,$mount_opts 0 0"
        echo "$fstab_entry" | sudo tee -a /etc/fstab
        
        echo -e "${GREEN}✓ Configuration updated successfully!${NC}"
        echo -e "${BLUE}Mount path: $mount_path${NC}"
        echo -e "${BLUE}Log pattern: $log_pattern${NC}"
    else
        echo -e "${RED}✗ Failed to remount S3 bucket.${NC}"
        return 1
    fi
    
    echo
}

# S3 bucket management menu
s3_bucket_menu() {
    while true; do
        echo -e "${CYAN}S3 Bucket Management${NC}"
        echo -e "${CYAN}====================${NC}"
        echo -e "${GREEN}1.${NC} View current S3 bucket mounts"
        echo -e "${GREEN}2.${NC} Mount new S3 bucket"
        echo -e "${GREEN}3.${NC} Remount existing S3 bucket"
        echo -e "${GREEN}4.${NC} Unmount S3 bucket"
        echo -e "${GREEN}5.${NC} Back to main menu"
        echo
        
        read -p "Enter your choice (1-5): " s3_choice
        echo
        
        case $s3_choice in
            1)
                show_s3_mounts
                ;;
            2)
                mount_s3_bucket
                ;;
            3)
                remount_s3_bucket
                ;;
            4)
                unmount_s3_bucket
                ;;
            5)
                return 0
                ;;
            *)
                echo -e "${RED}Invalid choice. Please select 1-5.${NC}"
                echo
                ;;
        esac
        
        # Pause before showing menu again
        read -p "Press Enter to continue..."
        echo
    done
}

# Loki configuration menu
loki_config_menu() {
    while true; do
        echo -e "${CYAN}Configure Loki${NC}"
        echo -e "${CYAN}==============${NC}"
        echo -e "${GREEN}1.${NC} Manage S3 Bucket Mounts"
        echo -e "${GREEN}2.${NC} Back to main menu"
        echo
        
        read -p "Enter your choice (1-2): " loki_choice
        echo
        
        case $loki_choice in
            1)
                s3_bucket_menu
                ;;
            2)
                return 0
                ;;
            *)
                echo -e "${RED}Invalid choice. Please select 1-2.${NC}"
                echo
                ;;
        esac
    done
}

# Main menu for existing setup
main_menu() {
    while true; do
        print_header
        echo -e "${CYAN}Configuration Options:${NC}"
        echo -e "${GREEN}1.${NC} Configure Loki"
        echo -e "${GREEN}2.${NC} Exit"
        echo
        
        read -p "Enter your choice (1-2): " main_choice
        echo
        
        case $main_choice in
            1)
                loki_config_menu
                ;;
            2)
                echo -e "${GREEN}Goodbye!${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}Invalid choice. Please select 1-2.${NC}"
                echo
                ;;
        esac
    done
}

# Initial setup workflow
initial_setup() {
    print_header
    echo -e "${YELLOW}Welcome! This appears to be your first time running the Observability Stack.${NC}"
    echo -e "${YELLOW}Let's set up your environment...${NC}"
    echo
    
    # Create .env file
    create_env
    echo
    
    # Set up systemd service
    setup_systemd_service
    echo
    
    echo -e "${GREEN}Initial setup completed successfully!${NC}"
    echo -e "${BLUE}You can run this script again to manage your configuration.${NC}"
    echo
}

# Cleanup function
cleanup() {
    [ -f "$TEMP_FILE" ] && rm -f "$TEMP_FILE"
}

# Set trap for cleanup
trap cleanup EXIT

# Main execution logic
main() {
    clear
    
    # Check if .env file exists
    if [ ! -f "$ENV_FILE" ]; then
        # First run - do initial setup
        initial_setup
    else
        # .env exists - source it for environment variables and show main menu
        echo -e "${BLUE}Loading environment variables from .env file...${NC}"
        set -a  # automatically export all variables
        source "$ENV_FILE"
        set +a  # stop automatically exporting
        main_menu
    fi
}

# Start the script
main 